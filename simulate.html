<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIREシミュレーション</title>
    <style>
        /* デザイン - ブラウザサイズまで広げ、収まらないときは垂直・水平スライダーで表示 */
        body {
            max-width: none !important;
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f4f7;
            color: #333;
            min-width: 1000px;
            /* 横スクロールを発生させやすくするための最小幅 */
        }

        h1,
        h2 {
            text-align: center;
            color: #2c3e50;
        }

        .simulation-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            /* ボタン間の間隔を調整 */
            justify-content: flex-start;
            /* 左揃え */
            margin-top: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .simulation-button {
            /* 試行回数の数字のみをテキストとするボタンを横に最大25個、左揃えで均等配置。 */
            flex-basis: calc(3%);
            /* 5pxのギャップで25個並べるための計算 */
            height: 30px;
            border-radius: 5px;
            border: 1px solid #ccc;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            line-height: 30px;
            font-size: 12px;
            padding: 0;
        }

        /* 4.2. 成功/失敗ボタン */
        .success {
            background-color: #3498db;
        }

        /* 青色: FIRE成功 */
        .failure {
            background-color: #e74c3c;
        }

        /* 赤色: FIRE失敗 */
        .simulation-button:hover {
            opacity: 0.8;
        }

        /* 4.3. シミュレーション詳細テーブルのデザイン */
        #detail-table-container {
            width: 100%;
            overflow-x: auto;
            /* 水平スクロール */
            margin-top: 30px;
            border: 1px solid #ccc;
            background-color: #fff;

            /* スクロール範囲を限定するために高さを指定 */
            height: 500px;
            /* 縦スクロールを有効にする */
            overflow-y: scroll;
        }

        #detail-table {
            width: 100%;
            font-size: 12px;
            table-layout: fixed;
            /* カラム幅を固定 */
        }

        /* 4.3. テーブル固定表示: テーブルの見出し（2行構成）は、縦スクロールしても常に最上部に表示されるよう固定。 */
        #detail-table thead {
            background-color: #f9f9f9;
            /* 見出しの背景色 */
        }

        #detail-table th,
        #detail-table td {
            border: 1px solid #ddd;
            text-align: center;
            vertical-align: middle;
            white-space: nowrap;
            /* セル内の改行を防ぐ（thは改行タグで制御） */
        }

        #detail-table th {
            background-color: #e9ecef;
            color: #495057;
            text-align: center;
            vertical-align: middle;
        }

        /* 共通項目のカラム幅を固定 */
        #detail-table tr th:nth-child(1),
        #detail-table tr td:nth-child(1) {}

        /* (1) 年月 */
        #detail-table th:nth-child(2),
        #detail-table td:nth-child(2) {}

        /* (2) 引継金融資産額 */
        #detail-table th:nth-child(3),
        #detail-table td:nth-child(3) {}

        /* (3) 出費 */
        #detail-table th:nth-child(4),
        #detail-table td:nth-child(4) {}

        /* (4) 収入 */
        #detail-table th:nth-child(5),
        #detail-table td:nth-child(5) {}

        /* (5) 税金 */
        #detail-table th:nth-child(6),
        #detail-table td:nth-child(6) {}

        /* (6) 保有現金 */
        #detail-table th:nth-child(7),
        #detail-table td:nth-child(7) {}

        /* (7) 追加投資 */
        #detail-table th:nth-child(8),
        #detail-table td:nth-child(8) {}

        /* (8) 期末金融資産額 */
        #detail-table th:nth-child(9),
        #detail-table td:nth-child(9) {}

        /* (9) 総資産 */

        /* 銘柄ごとの詳細カラム幅の固定 (4列: 60 + 100 + 100 + 130 = 390px) */
        /* 銘柄ごとの詳細列は10列目から開始 */
        #detail-table td:nth-child(4n + 10) {}

        /* 利率% */
        #detail-table td:nth-child(4n + 11) {}

        /* 金融資産額 */
        #detail-table td:nth-child(4n + 12) {}

        /* 保有口数の残数 */
        #detail-table td:nth-child(4n + 13) {}

        /* 現在/平均（税金/1口あたり） */


        /* 1. <thead>内の1行目（#header-row-1）のセルを固定 */
        /* <thead> > tr:nth-child(1) の中の th, td */
        #detail-table thead tr:nth-child(1) th,
        #detail-table thead tr:nth-child(1) td {
            /*固定位置を一番上 (0px) に設定 */
            position: sticky;
            top: 0;
            /*重なり順を設定 (固定部分を上に表示) */
            z-index: 20;
            /* 見やすくするために背景色を設定 */
            background-color: #f2f2f2;
        }

        /* 2. <thead>内の2行目（#header-row-2）のセルを、1行目の直下に固定 */
        /* <thead> > tr:nth-child(2) の中の th, td */
        #detail-table thead tr:nth-child(2) th,
        #detail-table thead tr:nth-child(2) td {
            position: sticky;
            top: 21px;
            background-color: #e6ffe6;
            z-index: 10;
        }

        /* <tr>2のセルは、<tr>1のセルの直下に固定されるように、topを調整します */
        /* <tr>1の高さが40pxだと仮定して設定 (実際の高さに合わせて調整が必要です) */
        tr:nth-child(2) th,
        tr:nth-child(2) td {
            top: 20px;
            background-color: #e6ffe6;
        }

        /* 実際の表示の調整: th (ヘッダー) のセルをより目立たせる */
        th {
            background-color: #ddd;
            z-index: 11;
            /* thの方がtdより上に来るように */
        }

        /* 銘柄ごとの１行目の銘柄毎の集団項目*/
        .meigara-header-group {
            cursor: pointer;
            /* クリック可能であることを示す */
            color: initial;
        }

        .collapsed-detail-text {
            display: none;
        }

        .showed-detail-button {
            padding: 10px 20px;
            border: 1px solid #999;
            background: yellow;
        }

        .kuchisu-increase {
            font-weight: bold;
            /* 口数増加時は太字 */
            color: #27ae60;
        }

        .text-left {
            text-align: left;
        }

        .result-stats {
            margin-top: 20px;
            font-size: 1.1em;
            text-align: center;
        }

        /* 凡例のスタイル */
        #meigara-legend {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #b3d4ff;
            border-radius: 5px;
            text-align: left;
            /* 左寄せ */
        }

        #meigara-legend h3 {
            margin-top: 0;
            font-size: 1.2em;
            color: #3498db;
        }

        /* グラフコンテナのスタイル */
        #chart-container {
            position: absolute;
            /* 絶対位置指定に変更 */
            display: none;
            /* 初期状態は非表示 */
            width: 600px;
            /* グラフの幅を指定 (調整可能) */
            max-width: 90%;
            /* 画面幅に応じた最大幅 */
            min-height: 350px;
            background-color: white;
            /* 背景色を追加 */
            border: 1px solid #ccc;
            /* 境界線を追加 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            /* 影を追加 */
            z-index: 100;
            /* 他の要素より手前に表示 */
            cursor: pointer;
            /* クリック可能を示すカーソル */
            padding: 10px;
            /* 内側の余白 */
            box-sizing: border-box;
            /* paddingを含めて幅計算 */
        }

        /* シミュレーション詳細セクションは常に表示しておく (テーブル用) */
        #simulation-detail {
            display: block;
            /* テーブル部分は常に表示 */
        }


        /* 5.4. デバッグ機能 */
        #debug-output {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #e74c3c;
            background-color: #fbe7e4;
            color: #c0392b;
            font-family: monospace;
            white-space: pre-wrap;
            display: none;
            /* 初期は非表示 */
        }
    </style>
</head>

<body>
    <header>
        <h1>FIREシミュレーション結果</h1>
        <a href="index.html" class="nav-button" style="display: block; width: 200px; margin: 0 auto 20px;">メイン画面に戻る</a>
    </header>

    <main>
        <section id="results-summary">
            <h2>シミュレーション結果の概要</h2>
            <div class="result-stats">
                <p id="summary-text">データ読み込み中...</p>
            </div>

            <div class="filter-controls" style="text-align: center; margin-bottom: 20px;">
                <label for="failure-filter">
                    <input type="checkbox" id="failure-filter"> 失敗したケースのみ表示
                </label>
            </div>

            <div id="simulation-buttons" class="simulation-buttons">
            </div>
        </section>

        <section id="simulation-detail" style="display: none;">
            <h2 id="detail-title" style="text-align: left;">シミュレーション詳細（試行 #1）</h2>
            <div id="chart-container" style="width: 95%; margin: 30px auto; min-height: 350px; cursor: pointer;">
                <canvas id="totalAssetChart"></canvas>
            </div>

            <div id="meigara-legend">
                <h3>凡例</h3>
            </div>

            <div id="detail-table-container">
                <table id="detail-table">
                    <thead>
                        <tr id="header-row-1">
                            <th class="text-left" id="header-row-1-month" rowspan="2">(1)<br>年月</th>
                        </tr>
                        <tr id="header-row-2">
                            <th>(2) 引継<br>金融資産額</th>
                            <th>(3) 出費</th>
                            <th>(4) 収入</th>
                            <th>(5) 税金</th>
                            <th>(6) 保有現金</th>
                            <th>(7) 追加投資</th>
                            <th>(8) 期末<br>金融資産額</th>
                            <th>(9) 総資産</th>
                        </tr>
                    </thead>
                    <tbody id="detail-table-body">
                    </tbody>
                </table>
            </div>
        </section>

        <div id="debug-output">
            <h3>デバッグ出力</h3>
            <pre id="debug-content"></pre>
        </div>

    </main>

    <script src="app.js"></script>
    <script src="chart.min.js"></script>

    <script>
        // --- numeric.js (最小限の機能のみを想定して、ここではダミー関数を定義します。実際のコードに差し替えてください。) ---
        const numeric = {
            rep: (row, col, value = 0) => {
                const matrix = [];
                for (let i = 0; i < row; i++) {
                    matrix.push(new Array(col).fill(value));
                }
                return matrix;
            },
            dot: (A, B) => {
                if (A[0].length !== B.length) {
                    console.error("行列の次元が一致しません");
                    return numeric.rep(A.length, B[0].length, 0);
                }
                const result = numeric.rep(A.length, B[0].length);
                for (let i = 0; i < A.length; i++) {
                    for (let j = 0; j < B[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < A[0].length; k++) {
                            sum += A[i][k] * B[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            },
            identity: (n) => {
                const matrix = numeric.rep(n, n);
                for (let i = 0; i < n; i++) {
                    matrix[i][i] = 1;
                }
                return matrix;
            },
            cholesky: (R) => {
                const n = R.length;
                const L = numeric.rep(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j <= i; j++) {
                        if (i === j) {
                            let sum = 0;
                            for (let k = 0; k < j; k++) {
                                sum += L[j][k] * L[j][k];
                            }
                            const diagVal = R[i][i] - sum;
                            if (diagVal < 0) {
                                throw new Error(`コレスキー分解エラー: 負の対角要素 (${diagVal.toFixed(4)})`);
                            }
                            L[i][j] = Math.sqrt(diagVal);
                        } else {
                            let sum = 0;
                            for (let k = 0; k < j; k++) {
                                sum += L[i][k] * L[j][k];
                            }
                            if (L[j][j] === 0) {
                                L[i][j] = 0;
                            } else {
                                L[i][j] = (R[i][j] - sum) / L[j][j];
                            }
                        }
                    }
                }
                return L;
            },
            transpose: (M) => {
                const rows = M.length;
                const cols = M[0].length;
                const result = numeric.rep(cols, rows);
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[j][i] = M[i][j];
                    }
                }
                return result;
            },
            random: {
                normal: (mu = 0, sigma = 1) => {
                    let u = 0, v = 0;
                    while (u === 0) u = Math.random();
                    while (v === 0) v = Math.random();
                    let mag = sigma * Math.sqrt(-2.0 * Math.log(u));
                    return mag * Math.cos(2.0 * Math.PI * v) + mu;
                }
            }
        };
        // --- numeric.js 終了 ---


        // --- モンテカルロ・シミュレーションのプログラムを関数に分割 ---

        const debugOutput = (message) => {
            const debugDiv = document.getElementById('debug-output');
            const debugContent = document.getElementById('debug-content');
            if (debugDiv && debugContent) {
                // debugDiv.style.display = 'block'; // デバッグ表示を有効にする場合はコメント解除
                debugContent.textContent += message + '\n';
            }
        };

        /**
         * 月次税率を決定する
         */
        function calculateTaxRate(monthIndex, taxEvents) {
            let rate = 0.20315; // デフォルト 20.315%
            const taxRateEvent = taxEvents.slice().reverse().find(t => monthIndex >= t.month);
            if (taxRateEvent) {
                rate = taxRateEvent.rate / 100;
            }
            return rate;
        }


        /**
         * 収入と出費を処理し、現金残高を更新し、不足額を返す
         * @param {number} monthIndex - 現在の経過月数
         * @param {number} currentCash - 現在の保有現金
         * @param {object} appData - アプリケーションデータ
         * @param {number} currentMonthlyLifeCost - インフレ適用済みの現在の月次生活費
         */
        function handleIncomeAndExpense(monthIndex, currentCash, appData, currentMonthlyLifeCost) {
            const { bigExpense, income } = appData;

            // 1. 収入処理 
            const incomeEvent = income.filter(inc =>
                monthIndex >= inc.startTotalMonths &&
                (inc.endTotalMonths === null || inc.endTotalMonths === undefined || monthIndex <= inc.endTotalMonths)
            );
            let monthlyIncome = 0;
            incomeEvent.forEach(inc => {
                monthlyIncome += inc.amount
            });
            currentCash += monthlyIncome;

            // 2. 出費処理
            const baseLifeCost = currentMonthlyLifeCost;

            // 大口出費を検索
            let bigExpenseAmount = 0;
            const bigExpenseEvent = bigExpense.filter(be => be.month === monthIndex);
            bigExpenseEvent.forEach(be => {
                bigExpenseAmount += be.amount;
            });

            // 月次総出費 (表示用/計算用)
            const monthlyTotalExpense = baseLifeCost + bigExpenseAmount;

            let requiredAssetSale = 0; // 不足額（資産売却が必要な額）
            let cashBalance = currentCash;

            if (cashBalance >= monthlyTotalExpense) {
                cashBalance -= monthlyTotalExpense;
            } else {
                requiredAssetSale = monthlyTotalExpense - cashBalance; // 不足額
                cashBalance = 0;
            }

            return {
                currentCash: cashBalance,
                monthlyIncome: monthlyIncome,
                totalExpense: monthlyTotalExpense, // (3) 出費表示用は、シンプルに月次総出費を返す
                requiredAssetSale: requiredAssetSale // 不足額
            };
        }



        /**
         * 追加投資を処理し、保有口数と平均取得価額を更新する
         */
        function handleTuikaInvestment(monthIndex, currentCash, currentStocks, appData, meigaraNames) {
            let tuikaEvents = [];
            // appData.tuika の各要素を順番に処理
            for (const tui of appData.tuika) {
                //対象外を外す
                //対象の期間ではないとき対象外とする
                if (tui.month > monthIndex || tui.toMonth_totalMonths < monthIndex) {
                    continue;
                }
                //パターンごとの処理。処理回数が多いもの順
                //各月なら対象。期間チェックはすでに済んでいるので省略
                if (tui.pattern === "各月") {
                    tuikaEvents.push(tui);
                    continue;
                }
                //１回かつ対象月なら対象
                if (tui.pattern === "１回"){
                    //対象月でなければ対象外
                    if(tui.month !== monthIndex) {
                        continue;
                    }
                    tuikaEvents.push(tui);
                    continue;
                }
                //各年のパターン
                //シミュレーション上の年月　から　追加投資開始年月の年月を引いて、１２で割り切れれば対象年月となる
                const w = monthIndex - tui.month;
                //１２で割り切れないときは対象外
                if (w % 12 === 0) {
                    tuikaEvents.push(tui);
                    continue;
                }
            }

            let monthlyTuikaInvestment = 0;

            for (const tuika of tuikaEvents) {
                const targetStockIndex = meigaraNames.indexOf(tuika.meigara);
                if (targetStockIndex === -1) continue;

                const targetStock = currentStocks[targetStockIndex];
                const investmentAmount = tuika.amount;

                if (currentCash < investmentAmount) {
                    debugOutput(`追加投資失敗(${tuika.meigara}): 現金不足。`);
                    continue;
                }

                currentCash -= investmentAmount;
                monthlyTuikaInvestment += investmentAmount;

                const pricePerUnit = targetStock.CurrentValuePerUnit / targetStock.Tani;
                if (pricePerUnit <= 0) continue;

                const boughtKuchisu = Math.floor(investmentAmount / pricePerUnit);

                const oldTotalValue = targetStock.Kuchisu * (targetStock.AveragePrice / targetStock.Tani);
                const newTotalValue = oldTotalValue + investmentAmount;
                const newTotalKuchisu = targetStock.Kuchisu + boughtKuchisu;

                targetStock.Kuchisu = newTotalKuchisu;

                if (newTotalKuchisu > 0) {
                    const newAveragePricePerUnit = newTotalValue / newTotalKuchisu;
                    targetStock.AveragePrice = newAveragePricePerUnit * targetStock.Tani;
                }
                debugOutput(`追加投資成功(${tuika.meigara}): 投資額${investmentAmount}, 購入口数${boughtKuchisu}`);
            }

            return { currentCash, monthlyTuikaInvestment };
        }

        /**
         * 現金不足を補うために金融資産を売却する
         */
        function handleAssetSale(requiredExpense, currentCash, currentStocks, trialCurrentTaxRate, monthIndex) {
            let sellProceeds = 0;
            let taxPayment = 0;
            let fireFailure = false;

            let totalFinancialAssets = currentStocks.reduce((sum, s) => {
                const valuePerUnit = s.CurrentValuePerUnit / s.Tani;
                return sum + (s.Kuchisu * valuePerUnit);
            }, 0);

            if (totalFinancialAssets < requiredExpense) {
                fireFailure = true;
                return { currentCash, taxPayment, sellProceeds, fireFailure };
            }

            let netSaleAmountNeeded = requiredExpense;
            let requiredSaleProceeds = netSaleAmountNeeded; // 売却総額（税引き前）の目標

            const MAX_SELL_TRIALS = 5; // 税金調整のための試行回数制限

            // 1. 税金を見越した目標売却総額の決定
            for (let sellTrial = 0; sellTrial < MAX_SELL_TRIALS; sellTrial++) {
                let totalGrossSaleAmount = 0;
                let calculatedTax = 0;

                const totalCurrentAssets = currentStocks.reduce((sum, s) => sum + (s.Kuchisu * (s.CurrentValuePerUnit / s.Tani)), 0);
                if (totalCurrentAssets <= 0) break;

                const targetSaleRatio = totalCurrentAssets > 0 ? requiredSaleProceeds / totalCurrentAssets : 0;

                for (const stock of currentStocks) {
                    const { CurrentValuePerUnit, AveragePrice, Tani, Kuchisu, TaxStartYear, TaxStartMonth } = stock;

                    const taxStartMonthIndex = TaxStartYear * 12 + (TaxStartMonth === 0 ? 0 : TaxStartMonth - 1);
                    const isTaxable = (TaxStartYear === null || TaxStartMonth === null) ? false :
                        ((TaxStartYear === 0 && (TaxStartMonth === 0 || TaxStartMonth === 1)) || monthIndex >= taxStartMonthIndex);
                    const hasProfit = CurrentValuePerUnit > AveragePrice;

                    const currentStockValue = Kuchisu * (CurrentValuePerUnit / Tani);
                    let targetSaleValue = currentStockValue * targetSaleRatio;
                    let actualKuchisuToSell = Math.ceil(targetSaleValue / (CurrentValuePerUnit / Tani));
                    actualKuchisuToSell = Math.min(Kuchisu, Math.max(0, actualKuchisuToSell));

                    const saleProceedsBeforeTax = actualKuchisuToSell * (CurrentValuePerUnit / Tani);
                    totalGrossSaleAmount += saleProceedsBeforeTax;

                    if (isTaxable && hasProfit && actualKuchisuToSell > 0) {
                        const profit = actualKuchisuToSell * ((CurrentValuePerUnit - AveragePrice) / Tani);
                        calculatedTax += profit * trialCurrentTaxRate;
                    }
                }

                taxPayment = calculatedTax; // 試行で計算された税額
                const netSaleProceeds = totalGrossSaleAmount - taxPayment;

                if (netSaleProceeds >= netSaleAmountNeeded) {
                    requiredSaleProceeds = totalGrossSaleAmount; // 必要な売却総額が確定
                    break;
                } else {
                    requiredSaleProceeds = (netSaleAmountNeeded + taxPayment); // 目標売却総額を増やして再試行
                    if (totalCurrentAssets < requiredSaleProceeds) {
                        requiredSaleProceeds = totalCurrentAssets;
                        break;
                    }
                }
            }

            // 2. 最終売却処理
            const finalTotalAssets = currentStocks.reduce((sum, s) => sum + (s.Kuchisu * (s.CurrentValuePerUnit / s.Tani)), 0);
            const finalTargetSaleRatio = finalTotalAssets > 0 ? requiredSaleProceeds / finalTotalAssets : 0;
            sellProceeds = 0;

            for (const stock of currentStocks) {
                const { CurrentValuePerUnit, Tani, Kuchisu } = stock;
                if (Kuchisu === 0) continue;

                const currentStockValue = Kuchisu * (CurrentValuePerUnit / Tani);
                let targetSaleValue = currentStockValue * finalTargetSaleRatio;
                let actualKuchisuToSell = Math.ceil(targetSaleValue / (CurrentValuePerUnit / Tani));
                actualKuchisuToSell = Math.min(Kuchisu, Math.max(0, actualKuchisuToSell));

                const saleProceedsBeforeTax = actualKuchisuToSell * (CurrentValuePerUnit / Tani);
                sellProceeds += saleProceedsBeforeTax;
                stock.Kuchisu -= actualKuchisuToSell;
            }

            const netSaleProceeds = sellProceeds - taxPayment;

            if (netSaleProceeds >= requiredExpense) {
                const surplusCash = netSaleProceeds - requiredExpense;
                currentCash += Math.floor(surplusCash); // 余剰金を現金に追加
            } else {
                fireFailure = true;
            }

            return { currentCash, taxPayment, sellProceeds, fireFailure };
        }

        /**
         * 銘柄の利率変動を適用し、月末の資産額と詳細を計算する
         */
        function applyMonthlyReturn(monthIndex, currentStocks, L, trialCurrentTaxRate) {
            const numStocks = currentStocks.length;
            const standardNormals = Array(numStocks).fill(0).map(() => numeric.random.normal());
            const Y = numeric.dot(L, standardNormals.map(n => [n]));
            const stockDetails = [];
            let endOfPeriodAssets = 0;

            for (let i = 0; i < numStocks; i++) {
                const stock = currentStocks[i];

                if (stock.Kuchisu <= 0) {
                    stockDetails.push({ rate: 0, value: 0, kuchisu: 0, currentValuePerUnit: 0, averagePrice: stock.AveragePrice, taxPerUnit: 0 });
                    continue;
                }

                // 利率変動計算
                const monthlyVolatility = stock.Volatility / 100 / Math.sqrt(12);
                const monthlyReturn = stock.Return / 100 / 12;
                const correlatedZ = Y[i][0];

                //その月のその銘柄に適用する、利率を計算する
                const monthlyRate = Math.exp(
                    (monthlyReturn - monthlyVolatility * monthlyVolatility / 2) +
                    (monthlyVolatility * correlatedZ)
                ) - 1;

                // 単位口数当たりの新しい価額に更新
                stock.CurrentValuePerUnit *= (1 + monthlyRate);

                // 新しい金融資産額
                const currentValuePerUnit = stock.CurrentValuePerUnit;
                const pricePerUnit = currentValuePerUnit / stock.Tani;
                const financialAssetValue = stock.Kuchisu * pricePerUnit;
                endOfPeriodAssets += financialAssetValue;

                // 表示用税額の計算
                let taxPerUnit = 0;
                const taxStartMonthIndex = stock.TaxStartYear * 12 + (stock.TaxStartMonth === 0 ? 0 : stock.TaxStartMonth - 1);
                const isTaxable = (stock.TaxStartYear === null || stock.TaxStartMonth === null) ? false :
                    ((stock.TaxStartYear === 0 && (stock.TaxStartMonth === 0 || stock.TaxStartMonth === 1)) || monthIndex >= taxStartMonthIndex);

                if (isTaxable && currentValuePerUnit > stock.AveragePrice) {
                    const profitPerUnit = (currentValuePerUnit - stock.AveragePrice) / stock.Tani;
                    taxPerUnit = profitPerUnit * trialCurrentTaxRate;
                }

                stockDetails.push({
                    rate: monthlyRate * 100, // %表示
                    value: financialAssetValue,
                    kuchisu: stock.Kuchisu,
                    currentValuePerUnit: currentValuePerUnit,
                    averagePrice: stock.AveragePrice,
                    taxPerUnit: taxPerUnit
                });
            }

            return { stockDetails, endOfPeriodAssets };
        }

        /**
         * モンテカルロ・シミュレーションを実行するメイン関数
         */
        function runMonteCarloSimulation(appData) {
            debugOutput('--- シミュレーション開始 ---');
            const config = appData.config;
            const stocks = appData.stocks;
            const totalPeriods = config.period * 12;
            const numTrials = config.times;
            const numStocks = stocks.length;
            const meigaraNames = stocks.map(s => s.Meigara);

            if (numStocks === 0) return [];


            // データの準備: 相関行列Rとコレスキー分解L
            const R = numeric.identity(numStocks);
            appData.soukan.forEach(item => {
                const indexA = meigaraNames.indexOf(item.A_Meigara);
                const indexB = meigaraNames.indexOf(item.B_Meigara);
                if (indexA !== -1 && indexB !== -1) {
                    R[indexA][indexB] = item.keisu;
                    R[indexB][indexA] = item.keisu;
                }
            });

            let L;
            try {
                L = numeric.cholesky(R);
            } catch (error) {
                debugOutput('エラー: コレスキー分解に失敗しました。' + error.message);
                alert('相関係数に矛盾等がある可能性が高いです。\nエラー: コレスキー分解に失敗しました。' + error.message);
                return [];
            }
            debugOutput('コレスキー分解完了。');

            const inflationRate = config.inflationRate / 100; // configから取得した%を小数に変換
            // LifeCostイベントを月数順にソート
            const lifeCostEvents = appData.lifeCost.sort((a, b) => a.month - b.month);
            let lifeCostEventIndex = -1;

            // 1. 初期生活費の特定 (month=0または最も早く発生するイベント)
            let currentMonthlyLifeCost = 0;
            if (lifeCostEvents.length > 0) {
                const initialLifeCostEvent = lifeCostEvents.find(lc => lc.month === 0);

                if (initialLifeCostEvent) {
                    // 0ヶ月目のイベントがあればそれを初期値とする
                    currentMonthlyLifeCost = initialLifeCostEvent.amount;
                    lifeCostEventIndex = lifeCostEvents.indexOf(initialLifeCostEvent);
                } else {
                    // 0ヶ月のイベントがない場合は、設定がないとみなし 0 円とする
                    currentMonthlyLifeCost = 0;
                }
            } else {
                // lifeCostの設定自体がない場合は0円
                currentMonthlyLifeCost = 0;
            }

            // lifeCostEventIndexが-1の場合、0番目の要素を指すように調整する
            if (lifeCostEventIndex === -1 && lifeCostEvents.length > 0) {
                // たとえ月が0でなくても、最初のイベントを起点としておく
                lifeCostEventIndex = 0;
                currentMonthlyLifeCost = lifeCostEvents[0].amount;
            }

            const simulationResults = [];

            // 全試行回数をループ
            for (let t = 0; t < numTrials; t++) {

                let lifeCostEventIndex = -1;
                let currentMonthlyLifeCost = 0;

                if (lifeCostEvents.length > 0) {
                    const initialLifeCostEvent = lifeCostEvents.find(lc => lc.month === 0);
                    if (initialLifeCostEvent) {
                        currentMonthlyLifeCost = initialLifeCostEvent.amount;
                        lifeCostEventIndex = lifeCostEvents.indexOf(initialLifeCostEvent);
                    } else {
                        currentMonthlyLifeCost = 0;
                    }
                } else {
                    currentMonthlyLifeCost = 0;
                }

                if (lifeCostEventIndex === -1 && lifeCostEvents.length > 0) {
                    lifeCostEventIndex = 0;
                    currentMonthlyLifeCost = lifeCostEvents[0].amount;
                }


                let currentCash = config.cash; // (6) 保有現金 (初期値)
                // 銘柄の初期状態をディープコピー
                const currentStocks = stocks.map(s => ({
                    ...s,
                    Kuchisu: s.Kuchisu,
                    CurrentValuePerUnit: s.CurrentValuePerUnit,
                    AveragePrice: s.AveragePrice,
                }));
                let fireFailure = false;
                let failureMonth = -1; // 失敗が確定した月数 (0ベース) を記録
                const history = [];

                // シミュレーション期間を月ごとにループ
                for (let monthIndex = 0; monthIndex < totalPeriods; monthIndex++) {

                    if (fireFailure) break;
                    const yearMonthStr = `${Math.floor(monthIndex / 12)}年${(monthIndex % 12) + 1}月`;

                    const transferAssets = monthIndex === 0 ?
                        stocks.reduce((sum, s) => sum + (s.Kuchisu / s.Tani * s.CurrentValuePerUnit), 0) :
                        history[monthIndex - 1].endOfPeriodAssets;

                    // 1. 月次税率の決定
                    const trialCurrentTaxRate = calculateTaxRate(monthIndex, appData.tax);

                    // 1. 月次インフレとライフコストイベントのチェック
                    let lifeCostReset = false;

                    // LifeCostイベントの切り替わりチェック (次のイベントがこの月に発生するか)
                    if (lifeCostEventIndex + 1 < lifeCostEvents.length) {
                        const nextEvent = lifeCostEvents[lifeCostEventIndex + 1];
                        if (monthIndex === nextEvent.month) {
                            // A期間からB期間への切替: B期間の予定出費（nextEvent.amount）を基準にリセット
                            // インフレ結果に関わらず、B期間の基準値で再スタートする
                            currentMonthlyLifeCost = nextEvent.amount;
                            lifeCostEventIndex++;
                            lifeCostReset = true;
                        }
                    }
                    // 毎年1月（monthIndexが12で割り切れる、かつ0ヶ月目ではない）にインフレを適用
                    // monthIndex 12, 24, 36, ... が 1月（経過1年後、2年後...の1月）
                    if (monthIndex > 0 && monthIndex % 12 === 0 && !lifeCostReset) {
                        currentMonthlyLifeCost *= (1 + inflationRate);
                    }
                    const monthlyLifeCostForSimulation = currentMonthlyLifeCost;


                    // 2. 収入と出費の処理 (追加投資・売却前の現金残高と不足額を計算)
                    const { currentCash: cashAfterIncomeExpense, monthlyIncome, totalExpense, requiredAssetSale } = handleIncomeAndExpense(
                        monthIndex,
                        currentCash,
                        appData,
                        monthlyLifeCostForSimulation // インフレ適用済み出費を渡す
                    );
                    currentCash = cashAfterIncomeExpense;
                    let requiredExpense = requiredAssetSale;

                    // 3. 追加投資処理
                    const tuikaResult = handleTuikaInvestment(monthIndex, currentCash, currentStocks, appData, meigaraNames);
                    currentCash = tuikaResult.currentCash;

                    // 4. 金融資産の売却 (現金不足の場合)
                    let taxPayment = 0;
                    if (requiredExpense > 0) {
                        const saleResult = handleAssetSale(requiredExpense, currentCash, currentStocks, trialCurrentTaxRate, monthIndex);
                        currentCash = saleResult.currentCash;
                        taxPayment = saleResult.taxPayment;
                        fireFailure = saleResult.fireFailure;
                        if (fireFailure) {
                            failureMonth = monthIndex; //ここで失敗月数を記録
                            debugOutput(`資産枯渇によりFIRE失敗 (${yearMonthStr})`);
                        }
                    }

                    // 5. 利率変動
                    const returnResult = applyMonthlyReturn(monthIndex, currentStocks, L, trialCurrentTaxRate);
                    const endOfPeriodAssets = returnResult.endOfPeriodAssets;
                    const stockDetails = returnResult.stockDetails;

                    // 6. 資産枯渇の確認 (総資産)
                    const totalAsset = endOfPeriodAssets + currentCash;
                    if (totalAsset < 0) {
                        fireFailure = true;
                        failureMonth = monthIndex; //ここで失敗月数を記録
                    }

                    // 月次履歴を記録
                    history.push({
                        yearMonth: yearMonthStr,
                        transferAssets: transferAssets, // (2) 引継金融資産額
                        expense: totalExpense, // (3) 出費 ← expenseResult.totalExpense を totalExpense に変更
                        income: monthlyIncome, // (4) 収入 ← expenseResult.monthlyIncome を monthlyIncome に変更
                        tax: taxPayment, // (5) 税金
                        cash: currentCash, // (6) 保有現金 (月末残高)
                        tuika: tuikaResult.monthlyTuikaInvestment, // (7) 追加投資
                        endOfPeriodAssets: endOfPeriodAssets, // (8) 期末金融資産額
                        totalAsset: totalAsset, // (9) 総資産
                        stockDetails: stockDetails,
                        isFailure: fireFailure
                    });
                }

                simulationResults.push({
                    trialId: t + 1,
                    success: !fireFailure,
                    failureMonth: fireFailure ? failureMonth : totalPeriods,
                    history: history
                });
                debugOutput(`試行 #${t + 1} 完了。成功: ${!fireFailure}`);

            }

            debugOutput('--- シミュレーション完了 ---');
            return simulationResults;
        }

        // --- モンテカルロ・シミュレーションのプログラム終了 ---

        //チャート生成用
        let totalAssetChartInstance = null;

        //すべての処理の前に登録データを整理する
        function initializeDatas() {
            //追加投資の終了年月をシミュレーションの年月に変換する
            const appDatas = JSON.parse(localStorage.getItem('fireSimulatorData')) || {};
            let new_data = [];
            for (let w of appDatas.tuika) {
                if (w.pattern === "１回") {
                    w.toMonth_totalMonths = w.month;
                }
                else {
                    //終了年月をシミュレーションの年月に変換する
                    w.toMonth_totalMonths = compareMonthAndGetCurrent(w.toMonth);
                }
                new_data.push(w);
            }
            appDatas.tuika = new_data;
            localStorage.setItem('fireSimulatorData', JSON.stringify(appDatas));
        }

        // ... (DOM操作と表示制御のコードは変更なし) ...
        document.addEventListener('DOMContentLoaded', () => {
            //処理前にデータを整理する
            initializeDatas();

            const simulationButtonsDiv = document.getElementById('simulation-buttons');
            const summaryText = document.getElementById('summary-text');
            const detailSection = document.getElementById('simulation-detail');
            const detailTitle = document.getElementById('detail-title');
            const detailTableBody = document.getElementById('detail-table-body');
            const failureFilter = document.getElementById('failure-filter');
            const meigaraLegend = document.getElementById('meigara-legend');
            const headerRow1 = document.getElementById('header-row-1');
            const headerRow2 = document.getElementById('header-row-2');

            const chartContainer = document.getElementById('chart-container'); // グラフコンテナを取得
            const totalAssetChartCanvas = document.getElementById('totalAssetChart'); // Canvas要素を取得

            let simulationResults = [];
            let currentTrialIndex = -1;
            let meigaraNames = [];

            /**
             * 銘柄ごとのヘッダーセルを動的に生成する
             * @param {Array} stocks - 銘柄情報の配列
             */
            function setupTableHeader(stocks) {
                let child = headerRow1.lastElementChild;
                while (child && child.id !== 'header-row-1-month') {
                    if (headerRow1.children.length > 1) {
                        headerRow1.removeChild(headerRow1.lastElementChild);
                    } else {
                        break;
                    }
                    child = headerRow1.lastElementChild;
                }

                while (headerRow2.children.length > 9) {
                    headerRow2.removeChild(headerRow2.lastChild);
                }

                meigaraNames = stocks.map(s => s.Meigara);

                // 銘柄の数だけヘッダーを追加
                stocks.forEach((stock, index) => {
                    // 1行目: 銘柄名
                    const th1 = document.createElement('th');
                    th1.colSpan = "4";
                    th1.textContent = `銘柄${String.fromCharCode(65 + index)}`

                    //銘柄をクリックすると、イベントが発動するようにする。	追加開始
                    th1.classList.add('meigara-header-group');
                    th1.classList.add('collapsed-detail-text');
                    th1.dataset.meigaraIndex = index; // 0, 1, 2, ... のインデックス
                    //銘柄をクリックすると、イベントが発動するようにする。	追加終了

                    headerRow1.appendChild(th1);

                    // 2行目: 詳細項目 (4つのセル)
                    const th2_rate = document.createElement('th');
                    th2_rate.textContent = '利率％';
                    th2_rate.classList.add('collapsed-detail-text');
                    headerRow2.appendChild(th2_rate);

                    const th2_value = document.createElement('th');
                    th2_value.textContent = '資産額';
                    th2_value.classList.add('collapsed-detail-text');
                    headerRow2.appendChild(th2_value);

                    const th2_kuchisu = document.createElement('th');
                    th2_kuchisu.textContent = '保有口数';
                    th2_kuchisu.classList.add('collapsed-detail-text');
                    headerRow2.appendChild(th2_kuchisu);

                    const th2_price = document.createElement('th');
                    th2_price.innerHTML = '現在/<br>平均<br>(税額/1口)';
                    th2_price.classList.add('collapsed-detail-text');
                    headerRow2.appendChild(th2_price);
                });

                // 1行目の共通項目のヘッダー（月次収支・資産総額）を動的に追加
                const th1_common = document.createElement('th');
                th1_common.colSpan = "8";
                th1_common.textContent = '月次収支・資産総額';
                headerRow1.insertBefore(th1_common, headerRow1.children[1]);

                // 凡例の設定
                const legendHtml = '<h3>凡例</h3>';
                meigaraLegend.innerHTML = legendHtml + stocks.map((s, i) =>
                    '<button onclick="showHideStocksInfo(' + `${i}` + ',this)">' + `銘柄${String.fromCharCode(65 + i)}: ${s.Meigara}` + '</button>'
                ).join('<br><br>') + '<BR><BR>※　凡例の「銘柄A、銘柄B・・・」をクリックすると、各銘柄の推移の表示・非表示を切り替えられます。<br>';
            }


            /**
             * シミュレーション詳細テーブルに結果を表示
             * @param {number} trialIndex - 表示する試行のインデックス
         * @param {HTMLElement} clickedButton - クリックされたボタン要素
             */
            function displaySimulationDetail(trialIndex, clickedButton) {
                currentTrialIndex = trialIndex;
                const result = simulationResults[trialIndex];
                const history = result.history;

                detailTitle.textContent = `シミュレーション詳細（試行 #${result.trialId} - ${result.success ? '成功' : '失敗'}）`;
                detailTableBody.innerHTML = ''; // テーブルをクリア

                history.forEach((entry, historyIndex) => {
                    const row = detailTableBody.insertRow();

                    // (1) 年月
                    let rowHtml = `<td class="text-left">${entry.yearMonth}</td>`;

                    // (2) 引継金融資産額 
                    let transferAssets = entry.transferAssets;
                    rowHtml += `<td>${window.formatNumber(transferAssets)}</td>`;

                    // (3) 出費 - 手取りとして必要な金額 
                    rowHtml += `<td>${window.formatNumber(entry.expense)}</td>`;
                    // (4) 収入
                    rowHtml += `<td>${window.formatNumber(entry.income)}</td>`;
                    // (5) 税金
                    rowHtml += `<td>${window.formatNumber(entry.tax)}</td>`;
                    // (6) 保有現金
                    rowHtml += `<td>${window.formatNumber(entry.cash)}</td>`;
                    // (7) 追加投資
                    rowHtml += `<td>${window.formatNumber(entry.tuika)}</td>`;

                    // (8) 期末金融資産額 - ( )をつけた対前月比の差を記載
                    const investmentChange = entry.endOfPeriodAssets - (entry.transferAssets + entry.tuika);
                    const assetChangeText = `${window.formatNumber(entry.endOfPeriodAssets)}<br>(${window.formatNumber(investmentChange)})`;
                    rowHtml += `<td>${assetChangeText}</td>`;

                    // (9) 総資産
                    rowHtml += `<td>${window.formatNumber(entry.totalAsset)}</td>`;

                    // 銘柄ごとの資産額の表示
                    entry.stockDetails.forEach((stock, stockIndex) => {
                        const initialStockData = window.appData.stocks[stockIndex];

                        // *保有口数の残数（セル）*
                        const prevStockKuchisu = historyIndex === 0 ? initialStockData.Kuchisu : history[historyIndex - 1].stockDetails[stockIndex].kuchisu;
                        const kuchisuChange = stock.kuchisu - prevStockKuchisu;
                        const kuchisuChangeText = kuchisuChange > 0 ? `<span class="kuchisu-increase">(+${window.formatNumber(kuchisuChange)})</span>` : `(${window.formatNumber(kuchisuChange)})`;
                        const kuchisuCell = `${window.formatNumber(stock.kuchisu)}<br>${kuchisuChangeText}`;

                        // *現在価額/平均取得価額（セル）*
                        const currentValuePerUnit = stock.currentValuePerUnit;
                        const averagePrice = stock.averagePrice;
                        const priceLine = `${window.formatNumber(currentValuePerUnit)}/${window.formatNumber(averagePrice)}`;

                        const taxPerUnitText = stock.taxPerUnit > 0.0000001 ? `(${stock.taxPerUnit.toFixed(4)}円/口)` : `無税`;

                        const priceCell = `${priceLine}<br>${taxPerUnitText}`;

                        // 銘柄の詳細情報のセルを追加
                        rowHtml += `
                            <td class='collapsed-detail-text'>${stock.rate.toFixed(2)}%</td>
                            <td class='collapsed-detail-text'>${window.formatNumber(stock.value)}</td>
                            <td class='collapsed-detail-text'>${kuchisuCell}</td>
                            <td class='collapsed-detail-text'>${priceCell}</td>
                        `;
                    });

                    row.innerHTML = rowHtml;
                    detailTableBody.appendChild(row);
                });

                detailSection.style.display = 'block';


                //グラフ描画ロジックの追加
                const labels = history.map(entry => entry.yearMonth);
                const data = history.map(entry => entry.totalAsset);

                const ctx = document.getElementById('totalAssetChart').getContext('2d');

                // 既存のグラフがあれば破棄して新しい描画に備える
                if (totalAssetChartInstance) {
                    totalAssetChartInstance.destroy();
                }

                // 新しい折れ線グラフを作成
                totalAssetChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            // 線形軸（左）にプロットするデータセット (必要に応じて残す)
                            {
                                label: '(9) 総資産の推移 (線形)',
                                data: data,
                                yAxisID: 'y', // 左側の軸を指定
                                borderColor: result.success ? '#3498db' : '#e74c3c',
                                backgroundColor: result.success ? 'rgba(52, 152, 219, 0.1)' : 'rgba(231, 76, 60, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1,
                                fill: false // 2つのプロットが重なるため、塗りつぶしはしない方が見やすい
                            },
                            // 対数軸（右）にプロットするデータセット (色は線形軸と変える)
                            {
                                label: '(9) 総資産の推移 (対数)',
                                data: data,
                                yAxisID: 'y2', // ★右側の対数軸を指定
                                borderColor: 'rgba(155, 89, 182, 1)', // 対数軸用に色を変更
                                backgroundColor: 'rgba(155, 89, 182, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1,
                                fill: false,
                                hidden: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `試行 #${result.trialId} の総資産の推移 (${result.success ? '成功' : '失敗'})`
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '期間'
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 20
                                }
                            },
                            y: { // 左側の通常の軸
                                title: {
                                    display: true,
                                    text: '総資産額 (線形)'
                                },
                                beginAtZero: false,
                                ticks: {
                                    callback: function (value) {
                                        return window.formatNumber(value);
                                    }
                                }
                            },
                            y2: { // 右側の対数軸を新設
                                type: 'logarithmic', // ★ここを 'logarithmic' に変更
                                position: 'right', // 軸を右側に配置
                                title: {
                                    display: true,
                                    text: '総資産額 (対数)'
                                },
                                grid: {
                                    drawOnChartArea: false, // グラフ領域へのグリッド線描画を無効化
                                },
                                ticks: {
                                    callback: function (value) {
                                        // 対数軸の目盛りを分かりやすくフォーマット
                                        return window.formatNumber(value);
                                    }
                                }
                            }
                        }
                    }
                });


                // --- ★グラフコンテナの位置計算と表示 ---
                if (clickedButton) {
                    const buttonRect = clickedButton.getBoundingClientRect();
                    const containerRect = simulationButtonsDiv.getBoundingClientRect(); // ボタンコンテナの位置

                    // ボタンの下端を基準に位置を計算 (スクロール位置も考慮)
                    let topPosition = window.scrollY + buttonRect.bottom;
                    let leftPosition = window.scrollX;

                    // 画面下部にはみ出す場合の調整 (簡易的)
                    const chartHeight = 350 + 20 + 2; // min-height + padding + border
                    if (topPosition + chartHeight > window.scrollY + window.innerHeight) {
                        topPosition = window.scrollY + buttonRect.top - chartHeight; // ボタンの上に表示
                        if (topPosition < window.scrollY) { // 画面上部にもはみ出すなら中央付近に
                            topPosition = window.scrollY + 50;
                        }
                    }

                    // 画面右側にはみ出す場合の調整
                    const chartWidth = 600 + 20 + 2; // width + padding + border
                    if (leftPosition + chartWidth > window.scrollX + window.innerWidth) {
                        leftPosition = window.scrollX + window.innerWidth - chartWidth - 10; // 右端に寄せる
                    }
                    if (leftPosition < window.scrollX) { // 画面左にもはみ出すなら中央付近に
                        leftPosition = window.scrollX + 10;
                    }


                    chartContainer.style.top = `${Math.max(0, topPosition)}px`;
                    chartContainer.style.left = `${Math.max(0, leftPosition)}px`;
                    chartContainer.style.display = 'block';
                } else {
                    chartContainer.style.display = 'none'; // ボタン情報がない場合は非表示
                }
            }

            /**
             * シミュレーションボタンの表示を更新
             * @param {boolean} showFailuresOnly - 失敗ケースのみを表示するかどうか
             */
            function updateSimulationButtons(showFailuresOnly) {
                simulationButtonsDiv.innerHTML = '';
                chartContainer.style.display = 'none';

                simulationResults.forEach((result, index) => {
                    if (showFailuresOnly && result.success) return;

                    const button = document.createElement('button');
                    button.id = `result-${result.trialId}`;
                    button.className = `simulation-button ${result.success ? 'success' : 'failure'}`;
                    button.textContent = result.trialId;

                    button.addEventListener('click', () => {
                        displaySimulationDetail(index, button);
                    });

                    simulationButtonsDiv.appendChild(button);
                });

                // 成功/失敗のサマリーを更新
                const successCount = simulationResults.filter(r => r.success).length;
                const failureCount = simulationResults.length - successCount;
                const successRate = (simulationResults.length > 0 ? successCount / simulationResults.length * 100 : 0).toFixed(1);

                // 1. 成功ケースの統計 (最終総資産)
                const successfulFinalAssets = simulationResults
                    .filter(r => r.success)
                    .map(r => r.history[r.history.length - 1].totalAsset);

                let medianAsset = 0;
                let worst10thAsset = 0;

                if (successfulFinalAssets.length > 0) {
                    medianAsset = calculatePercentile(successfulFinalAssets, 50);
                    worst10thAsset = calculatePercentile(successfulFinalAssets, 10);
                }

                // 2. 失敗ケースの統計 (最終総資産と失敗月数)
                const failureFinalAssets = simulationResults
                    .filter(r => !r.success)
                    .map(r => r.history[r.history.length - 1].totalAsset);

                const failureMonths = simulationResults
                    .filter(r => !r.success)
                    .map(r => r.failureMonth + 1); // 0ベースの月数に+1して表示月数に

                let medianFailureAsset = 0;
                let medianFailureMonth = 0;

                if (failureFinalAssets.length > 0) {
                    medianFailureAsset = calculatePercentile(failureFinalAssets, 50);

                    // 失敗確定期間の中央値（月数）を計算
                    medianFailureMonth = calculatePercentile(failureMonths, 50);
                }

                // 3. 全体評価の生成
                const overallAssessment = generateOverallAssessment(parseFloat(successRate), worst10thAsset);

                // 4. サマリーテキストの更新 (HTML構造の変更)
                // 月数を「X年 Yヶ月」形式に変換するヘルパー関数
                const formatMonths = (months) => {
                    const totalMonths = Math.round(months);
                    if (totalMonths <= 0) return "開始時";
                    const years = Math.floor(totalMonths / 12);
                    const m = totalMonths % 12;
                    if (years > 0) {
                        return `${years}年${m}ヶ月`;
                    }
                    return `${m}ヶ月`;
                };

                summaryText.innerHTML = `
			    <h2>全体評価</h2>
			    <p style="font-size: 1.2em; font-weight: bold; color: #2980b9;">
			        ${overallAssessment}
			    </p>
			    <hr style="margin: 15px 0;">

			    **試行回数:** ${simulationResults.length}回<br>
			    **FIRE成功率:** <span style="color:#3498db; font-size: 1.1em; font-weight: bold;">${successRate}%</span> (${successCount}回)<br>
			    **FIRE失敗率:** <span style="color:#e74c3c; font-size: 1.1em; font-weight: bold;">${(100 - successRate).toFixed(1)}%</span> (${failureCount}回)
			    <hr style="margin: 10px 0;">

			    <div style="display: flex; justify-content: space-around; text-align: left; padding: 10px;">
			        <div style="padding-right: 15px; flex: 1;">
		            <h3>✅ 成功ケース (最終総資産予測)</h3>
		            <p>
		                <span style="font-weight: bold;">中央値 (50%タイル):</span> ${window.formatNumber(Math.round(medianAsset))} 円<br>
		                <span style="font-weight: bold; color: #e67e22;">悲観的なケース (10%タイル):</span> ${window.formatNumber(Math.round(worst10thAsset))} 円
		            </p>
		            <span style="font-size: 0.9em; display: block;">※ 90%の確率で、10%タイル以上の資産が残ります。</span>
			        </div>
        
			        <div style="border-left: 1px solid #ccc; padding-left: 15px; flex: 1;">
			            <h3>❌ 失敗ケース (リスク分析)</h3>
			            <p>
			                <span style="font-weight: bold;">失敗までの期間 (中央値):</span> ${formatMonths(medianFailureMonth)}<br>
			                <span style="font-weight: bold; color: #c0392b;">終了時資産 (中央値):</span> ${window.formatNumber(Math.round(medianFailureAsset))} 円
			            </p>
			            <span style="font-size: 0.9em; display: block;">※ 失敗リスクが発生した場合、この期間で資産が枯渇する可能性が高いです。</span>
			        </div>
			    </div>
			`;
            }



            /**
                 * 配列から指定されたパーセンタイル値を計算する
                 * @param {Array<number>} data - 数値の配列
                 * @param {number} percentile - 求めるパーセンタイル (0-100)
                 * @returns {number} パーセンタイル値
                 */
            function calculatePercentile(data, percentile) {
                if (data.length === 0) return 0;
                const sortedData = [...data].sort((a, b) => a - b);
                const index = (percentile / 100) * (sortedData.length - 1);
                if (index % 1 === 0) {
                    return sortedData[index];
                } else {
                    const lower = Math.floor(index);
                    const upper = Math.ceil(index);
                    const weight = index - lower;
                    return sortedData[lower] * (1 - weight) + sortedData[upper] * weight;
                }
            }

            /**
                 * 成功率と悲観的なケースの資産額に基づき、総合的な評価文を生成する
                 */
            function generateOverallAssessment(successRate, worst10thAsset) {
                let assessment = "";

                if (successRate >= 99) {
                    stars = '⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐';
                    comment = `【評価：FIREしないリスクを検討しましょう😊】成功率 ${successRate.toFixed(1)} です。😊もはや、FIREせずに仕事を続けることのリスクを検討する段階です。<br>好きなことを仕事にしているなら続けましょう。<br>ですが、我慢をしている仕事ならば１度しかない人生だということも理解しておきましょう。<br>資産計画は極めて優秀です。【FIRE後、何をするか？】に注力しましょう。<br>健康寿命は思っている以上に短いですよ。`;
                } else if (successRate >= 95) {
                    stars = '⭐⭐⭐⭐⭐⭐⭐⭐⭐☆';
                    comment = `【評価：極めて高い確実性】成功率 ${successRate.toFixed(1)} で、あなたのFIRE計画は極めて高い確実性を持っています。<br>資産が枯渇する確率は非常に低いですが、さらなる特異な出費や、一時的な自国通貨安、または複数の危機が重なる「パーフェクトストーム」のような事態が連続すれば、最悪のシナリオでは枯渇する可能性も残ります。<br>計画は優秀ですが、まだ、穴があるようです。債券などの組み合わせも検討すれば、より確実なFIREができるかもしれません。<br>あわせて、FIRE後にすることを、そろそろ始めても良いころでは？`;
                } else if (successRate >= 90) {
                    stars = '⭐⭐⭐⭐⭐⭐⭐☆☆☆';
                    comment = `【評価：高い確実性だがリスクあり】成功率 ${successRate.toFixed(1)} は、比較的高い確実性です。<br>${(100 - successRate).toFixed(1)}%の確率で資産が尽きる未来が示されています。<br>予期せぬ大きな出費や、市場が長期間停滞する「パーフェクトストーム」のような事態が重なった場合、資産は枯渇します。<br>このリスクを真剣に受け止め、万が一の場合の収入源を確保するなど、より厳しい検討が必要です。<br>FIREはもう見えています。FIRE後にすることもきちんと計画しておきましょう。膨大な時間を有意義に消費するために。`;
                } else if (successRate >= 80) {
                    stars = '⭐⭐⭐⭐⭐☆☆☆☆☆';
                    comment = `【評価：危険水域・十分な検討が必要】成功率 ${successRate.toFixed(1)} は、FIREの確実性としては不十分です。<br>成功と失敗が約20%の差で発生しており、資産が枯渇する可能性は無視できません。<br>特異な出費や、一時的な自国通貨安、またはインフレの予想以上の進行が重なる最悪のケースでは、計画は容易に破綻します。<br>計画を実行に移す前に、資産の増強や生活費の見直しを強く推奨します。<br>FIREではなく、独立したい！というのであれば、生活への保険を掛けた状態で勝負に出ることができる水準です。もちろん運転資金としてこの資産に手を付けちゃだめですよ💦`;
                } else if (successRate >= 50) {
                    stars = '⭐⭐⭐☆☆☆☆☆☆☆';
                    comment = `【評価：極めて危険】成功率 ${successRate.toFixed(1)} は、失敗する確率が成功する確率とほとんど変わりません。<br>この状態でFIREを思考するのは極めて危険です。ほんの少しの事態で、あっという間に資産は枯渇します。<br>現状のデータでは正社員を辞めるべきではありません。適度にアルバイトすれば…は、現実逃避です。経済的独立は成立していません。<br>素直に会社員を続けましょう。`;
                } else if (successRate >= 40) {
                    stars = '⭐⭐☆☆☆☆☆☆☆☆';
                    comment = `【評価：ダメ絶対】成功率 ${successRate.toFixed(1)} は、シミュレーションの大半で資産が枯渇するという結果になりました。<br>この状態ではFIREのFの字すら語る段階では、まだありません。`;
                } else if (successRate >= 20) {
                    stars = '⭐☆☆☆☆☆☆☆☆☆';
                    comment = `【評価：え？】成功率 ${successRate.toFixed(1)}でした。<br>定率で右肩上がりに利益が出る非現実的なシミュレーターで満足しておくべき段階です。`;
                } else {
                    stars = '☆☆☆☆☆☆☆☆☆☆';
                    comment = `成功率 ${successRate.toFixed(1)} です。`;
                }

                assessment = stars + "<BR>" + comment;
                if (successRate >= 50 && worst10thAsset <= 0) {
                    assessment += "<br>→ **【注意】** 成功ケースであっても、運が悪いと資産がほとんど残らない（またはマイナスになる）可能性があります。";
                }

                return assessment;
            }


            // --- ★グラフ非表示のためのダブルクリックイベントリスナーを追加 ---
            chartContainer.addEventListener('dblclick', () => {
                chartContainer.style.display = 'none';
                if (totalAssetChartInstance) {
                    totalAssetChartInstance.destroy(); // グラフインスタンスも破棄
                    totalAssetChartInstance = null;
                }
            });



            // --- メイン処理 ---

            const storedData = localStorage.getItem('fireSimulatorData');
            if (!storedData) {
                summaryText.textContent = 'エラー: 設定データがLocalStorageに見つかりません。設定ページでデータを保存してください。';
                return;
            }

            try {
                //各種設定ページの設定情報の読み込み
                const appData = JSON.parse(storedData);
                window.appData = appData;

                if (!appData.stocks || appData.stocks.length === 0) {
                    summaryText.textContent = 'エラー: 保有銘柄が登録されていません。シミュレーションを実行できません。';
                    return;
                }

                // 1. ヘッダーの初期設定と凡例の準備
                setupTableHeader(appData.stocks);

                // 2. シミュレーションの実行 (simulate.htmlを開いた直後に開始)
                simulationResults = runMonteCarloSimulation(appData);

                // 3. 結果の表示
                updateSimulationButtons(false);

                // 4. 絞り込み機能のイベントリスナー
                failureFilter.addEventListener('change', (event) => {
                    updateSimulationButtons(event.target.checked);
                });

            } catch (e) {
                summaryText.textContent = `データの読み込みまたはシミュレーション実行中にエラーが発生しました: ${e.message}`;
                debugOutput(`致命的なエラー: ${e.stack}`);
                document.getElementById('debug-output').style.display = 'block';
            }
        });

        //シミュレーション詳細のテーブルの各銘柄の資産状況の推移情報の表示・非表示処理
        function showHideStocksInfo(meigaraIndex, event) {
            //押した銘柄のボタンの状態変更
            event.classList.toggle('showed-detail-button');

            // テーブルのすべての行 (ヘッダー行とデータ行) を取得
            const allRows = document.querySelectorAll('#detail-table tr');

            //1行目の銘柄A、銘柄B・・・の表示・非表示の変更
            const column = allRows[0].querySelectorAll('td, th')[meigaraIndex + 2];
            column.classList.toggle('collapsed-detail-text');

            // 銘柄の開始列インデックスを計算 (1-based index)
            const startColumnIndex_1based = 10 + (meigaraIndex * 4);
            //銘柄の詳細項目数を取得
            const COLUMNS_PER_STOCK = 4;
            //2行目以降の銘柄の詳細情報の表示・非表示の変更
            allRows.forEach(row => {
                // 4つの列をまとめて操作
                for (let i = 0; i < COLUMNS_PER_STOCK; i++) {
                    // 行が 'header-row-2' の場合、共通項目数は8（rowspan=2の影響で1つ少ない）
                    let columnIndex_1based = startColumnIndex_1based + i;
                    if (row.id === 'header-row-1') {	//1行目は別途処理する
                        continue;
                    }
                    if (row.id === 'header-row-2') {	//２行目だけ特殊なので、対象列を１つずらす
                        columnIndex_1based--;
                    }
                    // CSSの :nth-child(n) セレクタを使ってセルを取得
                    const cell = row.querySelector(`:nth-child(${columnIndex_1based})`);
                    if (cell) {
                        //選択した銘柄の詳細を表示・非表示を切り替える
                        cell.classList.toggle('collapsed-detail-text');
                    }
                }
            });
        }
    </script>
</body>

</html>